import { IMappingConversionOptions } from "./mapper.types";

/**
 * Converts data from global schema format to local format using the provided mapping
 */
export function fromGlobal({
    data,
    mapping,
}: IMappingConversionOptions): Record<string, unknown> {
    const result: Record<string, unknown> = {};

    // Process each mapping entry
    for (const [localKey, globalPath] of Object.entries(
        mapping.localToUniversalMap
    )) {
        // Handle comma-separated mappings (target,source)
        if (globalPath.includes(",")) {
            const [targetField, sourcePath] = globalPath
                .split(",")
                .map((s) => s.trim());

            // Extract the value from the source path
            const pathParts = sourcePath.split(".");
            let value: unknown = data;
            for (const part of pathParts) {
                if (value && typeof value === "object" && value !== null) {
                    value = (value as Record<string, unknown>)[part];
                } else {
                    value = undefined;
                    break;
                }
            }

            // Handle array of objects case
            if (Array.isArray(value)) {
                result[localKey] = value
                    .map((item) => {
                        if (item && typeof item === "object" && item !== null) {
                            return (item as Record<string, unknown>)[
                                targetField
                            ];
                        }
                        return undefined;
                    })
                    .filter((v) => v !== undefined);
            } else if (value && typeof value === "object" && value !== null) {
                // Handle single object case
                result[localKey] = (value as Record<string, unknown>)[
                    targetField
                ];
            }
            continue;
        }

        // Handle deep references (table references)
        if (globalPath.includes("(") && globalPath.includes(")")) {
            const [tableName, fieldPath] = globalPath.split("(");
            const fieldName = fieldPath.replace(")", "");

            // Extract the ID from the nested path
            const pathParts = fieldName.split(".");
            let value: unknown = data;
            for (const part of pathParts) {
                if (value && typeof value === "object" && value !== null) {
                    value = (value as Record<string, unknown>)[part];
                } else {
                    value = undefined;
                    break;
                }
            }

            // If we found a value, store it as a reference
            if (value !== undefined) {
                result[localKey] = value;
            }
        } else {
            // Handle direct field mapping
            if (globalPath in data) {
                result[localKey] = data[globalPath];
            }
        }
    }

    return result;
}

/**
 * Converts data from local format to global schema format using the provided mapping
 */
export function toGlobal({
    data,
    mapping,
}: IMappingConversionOptions): Record<string, unknown> {
    const result: Record<string, unknown> = {};

    // Process each mapping entry
    for (const [localKey, globalPath] of Object.entries(
        mapping.localToUniversalMap
    )) {
        // Handle comma-separated mappings (target,source)
        if (globalPath.includes(",")) {
            const [targetField, sourcePath] = globalPath
                .split(",")
                .map((s) => s.trim());

            // Create nested structure for the source path
            const pathParts = sourcePath.split(".");
            let current: Record<string, unknown> = result;

            // Build the nested structure
            for (let i = 0; i < pathParts.length - 1; i++) {
                const part = pathParts[i];
                current[part] = current[part] || {};
                current = current[part] as Record<string, unknown>;
            }

            // Handle array of objects case
            if (Array.isArray(data[localKey])) {
                const lastPart = pathParts[pathParts.length - 1];
                current[lastPart] = (data[localKey] as unknown[]).map(
                    (item) => ({
                        [targetField]: item,
                    })
                );
            } else if (localKey in data) {
                // Handle single object case
                const lastPart = pathParts[pathParts.length - 1];
                current[lastPart] = {
                    [targetField]: data[localKey],
                };
            }
            continue;
        }

        // Handle deep references (table references)
        if (globalPath.includes("(") && globalPath.includes(")")) {
            const [tableName, fieldPath] = globalPath.split("(");
            const fieldName = fieldPath.replace(")", "");

            // Create nested structure for the reference
            const pathParts = fieldName.split(".");
            let current: Record<string, unknown> = result;

            // Build the nested structure
            for (let i = 0; i < pathParts.length - 1; i++) {
                const part = pathParts[i];
                current[part] = current[part] || {};
                current = current[part] as Record<string, unknown>;
            }

            // Set the final value
            const lastPart = pathParts[pathParts.length - 1];
            if (localKey in data) {
                current[lastPart] = data[localKey];
            }
        } else {
            // Handle direct field mapping
            if (localKey in data) {
                result[globalPath] = data[localKey];
            }
        }
    }

    return result;
}
