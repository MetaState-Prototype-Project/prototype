<script lang="ts">
	import { page } from '$app/state';
	import { PUBLIC_PICTIQUE_BASE_URL } from '$env/static/public';
	import { ChatMessage, MessageInput } from '$lib/fragments';
	import { apiClient, getAuthToken } from '$lib/utils/axios';
	import moment from 'moment';
	import { onMount } from 'svelte';

	const id = page.params.id;
	let userId = $state();
	let messages: Record<string, unknown>[] = $state([]);
	let messageValue = $state('');
	let messagesContainer: HTMLDivElement;

	// Function to remove duplicate messages by ID
	function removeDuplicateMessages(
		messagesArray: Record<string, unknown>[]
	): Record<string, unknown>[] {
		const seen = new Set<string>();
		return messagesArray.filter((msg) => {
			const id = msg.id as string;
			if (seen.has(id)) {
				console.log(`Removing duplicate message with ID: ${id}`);
				return false;
			}
			seen.add(id);
			return true;
		});
	}

	function scrollToBottom() {
		if (messagesContainer) {
			messagesContainer.scrollTop = messagesContainer.scrollHeight;
		}
	}

	// Scroll to bottom when messages change
	$effect(() => {
		if (messages) {
			// Use setTimeout to ensure DOM has updated
			setTimeout(scrollToBottom, 0);
		}
	});

	async function watchEventStream() {
		const sseUrl = new URL(
			`/api/chats/${id}/events?token=${getAuthToken()}`,
			PUBLIC_PICTIQUE_BASE_URL
		).toString();
		const eventSource = new EventSource(sseUrl);

		eventSource.onopen = () => {
			console.log('Successfully connected.');
		};

		eventSource.onmessage = (e) => {
			try {
				const data = JSON.parse(e.data);
				console.log('ðŸ“¨ SSE message received:', data);
				console.log('Current messages count before adding:', messages.length);
				addMessages(data);
				console.log('Messages count after adding:', messages.length);
				// Use setTimeout to ensure DOM has updated
				setTimeout(scrollToBottom, 0);
			} catch (error) {
				console.error('Error parsing SSE message:', error);
			}
		};
	}

	async function handleSend() {
		await apiClient.post(`/api/chats/${id}/messages`, {
			text: messageValue
		});
		messageValue = '';
	}

	function addMessages(arr: Record<string, unknown>[]) {
		console.log('Raw messages:', arr);
		console.log('Current userId:', userId);

		const newMessages = arr.map((m) => {
			// Check if this is a system message (no sender)
			const isSystemMessage =
				!m.sender || m.text?.toString().startsWith('$$system-message$$');

			if (isSystemMessage) {
				// Handle system messages - they don't have a sender
				return {
					id: m.id,
					isOwn: false, // System messages are not "owned" by any user
					userImgSrc: '/images/system-message.png', // Default system message icon
					time: moment(m.createdAt as string).fromNow(),
					message: m.text,
					isSystemMessage: true
				};
			}

			// Handle regular user messages
			const sender = m.sender as Record<string, string>;
			const isOwn = sender.id !== userId;

			console.log('Message sender ID:', sender.id, 'User ID:', userId, 'IsOwn:', isOwn);

			return {
				id: m.id,
				isOwn: isOwn,
				userImgSrc: sender.avatarUrl,
				time: moment(m.createdAt as string).fromNow(),
				message: m.text,
				isSystemMessage: false,
				senderId: sender.id,
				senderName: sender.name,
				senderHandle: sender.handle
			};
		});
		apiClient.post(`/api/chats/${id}/messages/read`);

		// Process messages to determine which ones need heads and timestamps
		const processedMessages = newMessages.map((msg, index) => {
			const prevMessage = index > 0 ? newMessages[index - 1] : null;
			const nextMessage = index < newMessages.length - 1 ? newMessages[index + 1] : null;

			// Show head (avatar, pointer) on first message of group
			const isHeadNeeded = !prevMessage || prevMessage.isOwn !== msg.isOwn;

			// Show timestamp on last message of group
			const isTimestampNeeded = !nextMessage || nextMessage.isOwn !== msg.isOwn;

			return {
				...msg,
				isHeadNeeded,
				isTimestampNeeded
			};
		});

		// Prevent duplicate messages by checking IDs
		const existingIds = new Set(messages.map((msg) => msg.id));
		const uniqueNewMessages = processedMessages.filter((msg) => !existingIds.has(msg.id));

		if (uniqueNewMessages.length > 0) {
			console.log(`Adding ${uniqueNewMessages.length} new unique messages`);
			const newMessagesArray = messages.concat(uniqueNewMessages);
			// Final safety check to remove any duplicates
			messages = removeDuplicateMessages(newMessagesArray);
		} else {
			console.log('No new unique messages to add');
		}
	}

	onMount(async () => {
		const { data: userData } = await apiClient.get('/api/users');
		userId = userData.id;
		watchEventStream();
	});
</script>

<section class="chat relative px-0">
	<div class="h-[calc(100vh-220px)] overflow-auto" bind:this={messagesContainer}>
		{#each removeDuplicateMessages(messages) as msg (msg.id)}
			<ChatMessage
				isOwn={msg.isOwn as boolean}
				userImgSrc={msg.userImgSrc as string}
				time={msg.time as string}
				message={msg.message as string}
				isHeadNeeded={msg.isHeadNeeded as boolean}
				isTimestampNeeded={msg.isTimestampNeeded as boolean}
				sender={msg.isSystemMessage
					? null
					: {
							id: msg.senderId as string,
							name: msg.senderName as string,
							handle: msg.senderHandle as string,
							avatarUrl: msg.userImgSrc as string
						}}
			/>
		{/each}
	</div>
	<MessageInput
		class="sticky start-0 bottom-[-15px] w-full"
		variant="dm"
		src="https://picsum.photos/id/237/200/300"
		bind:value={messageValue}
		{handleSend}
	/>
</section>
